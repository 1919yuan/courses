(define (inconsistent? m1 m2)
 (some (lambda (binding1)
	(some (lambda (binding2)
	       (and (eq? (first binding1) (first binding2))
		    (not (eq? (second binding1) (second binding2)))))
	      m2))
       m1))

(define (a-model-of omega)
 (if (symbol? omega)
     (list (list omega #t))
     (case (first omega )
      ((not)
       (let ((omega (second omega)))
	(if (symbol? omega)
	    (list (list omega #f))
	    (case (first omega)
	     ((not) (a-model-of (second omega)))
	     ((and) (a-model-of `(or (not ,(second omega))
				     (not ,(third omega)))))
	     ((or) (a-model-of `(and (not ,(second omega))
				     (not ,(third omega)))))
	     ((implies) (a-model-of `(and ,(second omega)
					  (not ,(third omega)))))
	     ((iff) (a-model-of
		     `(or (not (implies ,(second omega) ,(third omega)))
			  (not (implies ,(third omega) ,(second omega))))))
	     (else (panic "Invalid formula"))))))
      ((and)
       (let ((m1 (a-model-of (second omega)))
	     (m2 (a-model-of (third omega))))
	(when (inconsistent? m1 m2) (fail))
	(union m1 m2)))
      ((or) (either (a-model-of (second omega))
		    (a-model-of (third omega))))
      ((implies) (a-model-of `(or (not ,(second omega)) ,(third omega))))
      ((iff) (a-model-of `(and (implies ,(second omega) ,(third omega))
			       (implies ,(third omega) ,(second omega)))))
      (else (panic "Invalid formula")))))

(define (models omega) (all-values (one-value (a-model-of omega))))

(define (list->conjunction sigma)
 (if (null? (rest sigma))
     (first sigma)
     `(and ,(first sigma) ,(list->conjunction (rest sigma)))))

(define (entails? sigma phi)
 (null? (models (list->conjunction (union sigma (list `(not ,phi)))))))
